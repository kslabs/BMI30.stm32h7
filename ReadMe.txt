/*
Обновлённое описание (оптимизация частоты семплирования и опорной частоты передачи)
====================================================================================

Цель
----
Реалтайм периферийный модуль на STM32H723VGT6 (WeAct) для Raspberry Pi 5: генерация двух фазосдвигаемых
меандров, синхронный захват двух аналоговых каналов, минимально‑накладная передача по USB FS (Vendor Bulk)
с возможностью последующей синхронизации с внешними 50/60 Гц.

Ключевые требования
-------------------
1. Два выходных канала (A,B) – меандр ~200…300 Гц с регулировкой фазы 0–360° (шаг ≤1°).
2. Два входных канала (ADC1, ADC2) – равная частота дискретизации Fs.
3. Непрерывный поток в RPi5 ≈ до предела USB FS (реалистично 1.05…1.15 MB/s полезной нагрузки без short packets).
4. Передача буферов независимо по каждому АЦП (не смешивать «стерео»), каждый блок: Header(32B)+Samples.
5. Заголовок + данные без внутреннего short packet: (32 + 2*N) % 64 == 0 (нулевой паддинг).
6. Возможность точной фазовой/частотной синхронизации с 50/60 Гц.

Условие выравнивания USB
------------------------
(32 + 2*N) ≡ 0 (mod 64)  ⇒  2N ≡ 32 (mod 64)  ⇒  N ≡ 16 (mod 32).
Т.е. N = 16 + 32·k (k = 0,1,2,…).

Синхронизация с 50/60 Гц
------------------------
Чтобы обе частоты 50 и 60 Гц укладывались в целое число буферов периода:
Пусть f_buf – частота формирования/передачи буферов. Нужно:
20 ms * f_buf = целое   и   (1000/60) ms * f_buf = целое.
Минимальное общее решение: f_buf = 300 Гц (для 50 Гц: 6 буферов, для 60 Гц: 5 буферов за период).
Текущие 200 Гц дают 4 буфера на 50 Гц (OK), но 3.333 буфера на 60 Гц (дробно → сложнее синхронизация).

Метрики
-------
Payload/буфер (байт) = 2*N.
Полный блок = 32 + 2*N (у нас без паддинга).
Скорость (два АЦП) = (32 + 2*N) * f_buf * 2  (байт/с).
Нагрузка заголовка (%) ≈ 32 / (2*N) * 100.
Fs = N * f_buf (при отсутствии пропусков между буферами).

Варианты конфигураций
---------------------
(Все соответствуют N ≡ 16 (mod 32))

A) Базовый «200 Гц» (минимум изменений)
   f_buf = 200 Гц
   Выберем N = 1360 (ближайшее к прежним 1375, соблюдает условие)
   Fs = 272000 сэмпл/с
   Размер блока (на АЦП): 32 + 2720 = 2752 B (64 * 43)
   Поток (2 АЦП): 2752 * 200 * 2 = 1,100,800 B/s ≈ 1.051 MiB/s
   Overhead ≈ 1.18%
   + Простая миграция
   – Сложнее синхронизация с 60 Гц (нецелое число буферов)

A′) Точно сохранить прежний Fs ≈ 275 kHz
    Если оставить Fs=275000 и N=1360 ⇒ f_buf = 275000/1360 ≈ 202.21 Гц
    Поток ≈ 1.112 MB/s
    + Чуть выше временное разрешение
    – Буферная частота «не круглая», нет целых отношений ни с 50, ни с 60 Гц

B) Компромисс «универсальная синхронизация» (рекомендованный вариант №1)
   f_buf = 300 Гц (делит периоды 50 и 60 Гц на целые числа буферов)
   Возьмём N = 912 (ближе к текущему Fs, снижает риск выхода за пределы реальной пропускной способности)
   Fs = 912 * 300 = 273600 сэмпл/с (~ −0.5% от 275 k)
   Блок: 32 + 1824 = 1856 B (64 * 29)
   Поток: 1856 * 300 * 2 = 1,113,600 B/s ≈ 1.062 MiB/s
   Overhead ≈ 1.74%
   + Целые отношения: 50 Гц = 6 буферов; 60 Гц = 5 буферов
   + Почти исходный Fs (степень сохранения спектральных свойств)
   + Запас по USB (без экстремального приближения к потолку)
   – Чуть больше относительный overhead против больших N (но приемлемо)

C) Максимизация выборок при 300 Гц (верхний предел без выхода за ~1.15 MB/s)
   Выше N = 944
   Fs = 944 * 300 = 283200 сэмпл/с (+2.98% к 275 k)
   Блок: 32 + 1888 = 1920 B (64 * 30)
   Поток: 1920 * 300 * 2 = 1,152,000 B/s ≈ 1.098 MiB/s
   Overhead ≈ 1.69%
   + Больше данных/буфер (длиннее окно наблюдения)
   – Меньше запас пропускной способности (ближе к реальному лимиту FS)
   – Требует подтверждения что ADC/тактовая схема легко дойдёт до 283.2 kS/s стабильных

D) Ещё больше Fs при 300 Гц
   N = 976 ⇒ Fs = 292800 сэмпл/с
   Поток: (32+1952)=1984; 1984*300*2=1,190,400 B/s ≈ 1.135 MiB/s
   Очень близко к верхнему устойчивому пределу; риск периодических short packet / пропусков – НЕ рекомендую как дефолт.

Сравнение 200 Гц vs 300 Гц
--------------------------
200 Гц (N≈1360): длиннее интервал (5 ms) – удобны «широкие» зоны; хуже унифицированная синхронизация с 60 Гц.
300 Гц (N≈912…944): короче интервал (3.333 ms) – выше временное разрешение фазовых эффектов, проще фазовая подстройка
к 50/60 Гц (целые буферы на период), немного больше «заголовков в секунду», но прирост overhead незначим.

Рекомендация по умолчанию
-------------------------
Принять конфигурацию B:
  f_buf = 300 Гц
  N = 912 (N ≡16 mod32)
  Fs = 273600 сэмпл/с
  Поток ≈ 1.11 MB/s (два АЦП)
  Целые отношения с 50/60 Гц, умеренная нагрузка на USB и CPU.
При необходимости большего динамического диапазона / разрешения по частоте можно опционально включить профиль C (N=944).

Переопределение зон интереса
----------------------------
Переход от 5.0 ms буфера (200 Гц) к 3.333 ms (300 Гц) означает пересчёт зон по ВРЕМЕНИ, а не по индексам.
Предлагаемый формат команд с хоста: задать зоны в микросекундах (offset_us, length_us). В прошивке:
  sample_index = (offset_us * Fs) / 1e6.
Это гарантирует неизменность ROI при смене (N, f_buf, Fs).

Заголовок блока (32 байта)
--------------------------
Offset Size  Поле
0      2     Magic 0xA55A
2      1     Version=1
3      1     Flags (bit0=ADC_ID; bit1=Mode FULL/ROI1/ROI2; bit2=CRC; прочие зарез.)
4      4     Seq (per-ADC)
8      4     Timestamp (например монотонный 32-битный таймер 1 us / 10 us)
12     2     TotalSamples (фактически передано в payload)
14     2     ZoneCount (0/1/2)
16     4     Zone1_Offset (в выборках относительно начала полного буфера)
20     4     Zone1_Length
24     4     Zone2_Offset
28     2     Zone2_Length
30     2     CRC16 (header+data или 0 если отключено)
Далее payload (либо весь буфер N, либо конкатенация зон), без паддинга (по условию выбора N), сразу кратно 64.

Алгоритм синхронизации с 50/60 Гц (эскиз)
----------------------------------------
1. Выбор f_buf=300 Гц.
2. Детектор внешнего нуля (или фронта) 50/60 Гц → метка времени T_ext.
3. Расчёт дрейфа: ожидаемый интервал между 5 (60 Гц) или 6 (50 Гц) буферами.
4. PID/PI корректирует ARR/PSC опорного таймера (TIM6) малыми дельтами, удерживая фазу.
5. Ограничение: частотное окно подстройки ±2% (гистерезис) во избежание «охоты» при шуме.

Действия для перехода на профиль B
----------------------------------
1. Константы: #define BUF_FREQ 300, #define SAMPLES_PER_BUF 912.
2. Настройка TIM15 (триггер ADC): Fs = BUF_FREQ * SAMPLES_PER_BUF.
3. Перерасчёт PSC/ARR для требуемого Fs с учётом реального тактирования (D2PCLKx).
4. Очередь буферов: обновить размер/маски (N и количество буферов в кольце остаётся ≥8).
5. Параметры зон – хранить в микросекундах → пересчёт в индекс при формировании блока.
6. Обновить документацию протокола (данный файл).
7. Добавить профиль C (N=944) как альтернативу через команду CMD_SET_PROFILE.

Расчёт примера (Fs 273600 Hz)
-----------------------------
Тактовая TIM (пример) = 200 MHz. Ищем PSC, ARR:
Fs = F_tim / ((PSC+1)*(ARR+1)) ⇒ хотим 273600.
Выбор: PSC=4 (деление на 5) ⇒ F_int=40 MHz.
ARR ≈ (40,000,000 / 273,600) - 1 ≈ 145.23 ⇒ ARR=145.
Реальный Fs = 40,000,000 / 5 / 146 = 273,972 Hz (+0.14%). Допустимо.
Если нужен более точный – подобрать другое (PSC,ARR) или включить fractional подстройку через периодическое
вставление/пропуск тактов (диффузия ошибки).

Статистика (для телеметрии)
---------------------------
- sent_blocks_per_adc
- dropped_blocks_per_adc
- max_backlog
- last_sync_error_ns (ошибка фазы с внешним 50/60 Гц)
- current_profile (идентификатор текущей пары {f_buf, N})

Краткое резюме выбора
---------------------
Default: f_buf=300 Гц, N=912, Fs≈273.6 kS/s (zero‑padding free, синхронизация 50/60 Гц целочисленная, поток ≈1.11 MB/s).
Alt High: N=944 (Fs≈283.2 kS/s) если подтвердится запас по USB и ADC.
Legacy: f_buf=200 Гц, N=1360 (Fs=272 кС/с) при необходимости совместимости/длинного окна.

Дальнейшие шаги
---------------
1. Реализовать выбор профиля по команде.
2. Перевести ROI на время‑ориентированную адресацию.
3. Добавить фазовую подстройку (опционально – позже).
4. Тест непрерывного стрима >30 мин без потерь (проверка seq).

(Старое описание сохранено в системе управления версиями; при необходимости можно восстановить.)

*/

Быстрый smoke‑тест (Windows / PowerShell)
=========================================

Цель: убедиться, что устройство корректно выдаёт STAT только между парами кадров и строгий порядок A→B соблюдается.

Предпосылки
- Установлен Python 3.8+ и пакеты: `pip install pyusb libusb-package`
- На интерфейс #2 (Vendor) привязан WinUSB (через Zadig → Options → List All Devices → выбрать Interface 2 → WinUSB → Install)

Проверка устройства
- `python -c "import usb.core;print(usb.core.find(idVendor=0xCAFE,idProduct=0x4001))"`

Запуск чтения (~20 FPS)
- 200 Гц, Ns=10:
   - `python HostTools/vendor_stream_read.py --vid 0xCAFE --pid 0x4001 --intf 2 --ep-in 0x83 --ep-out 0x03 --profile 2 --block-hz 200 --frame-samples 10 --frames 80 --ab-strict`

- 300 Гц, Ns=15:
   - `python HostTools/vendor_stream_read.py --vid 0xCAFE --pid 0x4001 --intf 2 --ep-in 0x83 --ep-out 0x03 --profile 2 --block-hz 300 --frame-samples 15 --frames 100 --ab-strict`

Ожидаемое поведение
- После START: один STAT (ACK), затем немедленно кадр A, сразу за ним B; seq у B совпадает с последним A.
- В полном режиме STAT идёт только между завершёнными парами A/B; появление STAT «внутри пары» — нарушение.
- Итоговая строка у скрипта покажет pairs_fps, близкий к ~20 для указанных настроек.

Примечания
- В простое таймауты IN — нормальны; чтение возобновляется с очередным A. Можно периодически посылать GET_STATUS.
- Для RPi смотрите `HostTools/rpi_vendor_start_and_read.py` (аналогичная логика, отдельные параметры USB доступа).
